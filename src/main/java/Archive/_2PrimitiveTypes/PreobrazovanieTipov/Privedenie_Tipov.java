package Archive._2PrimitiveTypes.PreobrazovanieTipov;

public class Privedenie_Tipov {
    public static void main(String[] args) {
        // При приведении более ёмкого целого бита к менее емк.цел.типу лишние старшие биты отбрасываются
        // и для компелятора требуется подтверждение в какой тип переводить - указываем в сеобках после равно = (int)...
        int x = 1024;
        byte y = (byte)x; // При приведении более ёмкого целого бита к менее емк.цел.типу лишние старшие биты отбрасываются
        System.out.println(y); // 0 - выведет в консоль если х = 1024

        double pi = 3.14;
        int intFromDouble = (int) pi;
        System.out.println(intFromDouble);

        float largeFloat = 1e20f; // 1.0E20 (при выводе на печать) это 10 ^20  (в 20 степени)
        int intFromlargeFloat = (int)largeFloat;
        System.out.println(intFromlargeFloat);  //  2_147_483_647 (при выводе на печать) округлило до 2 * 10 ^9

        double largeDouble = 1e100;            // 1.0E100 (при выводе на печать) - хз что за цифра но большая
        float floatFromlargeDouble = (float)largeDouble;
        System.out.println(floatFromlargeDouble); // Infinity (+бесконечночть) - выведет в консоль при largeDouble = 1e100

        // Автоматическое расширение происхоидит принудительно - операнды приводится к одному типу.
        double doubleValue = 1d + 1f;  // Приводится к double если хотя бы 1 операнда - double.
        float floatValue = 1f * 1;     // иначе: приводится к float если хотя бы 1 операнда - float.
        long longValue = 1L - '0';     // иначе: приводится к long если хотя бы 1 операнда - long.
                       // иначе: приводится к типу int:
        byte a = 1;
        byte b = 2;
        byte c = ( byte ) ( a + b ); // когда складываю 2 значения типа byte то получаю int и присвоить значение
        // в переменную типа byte без явного привдеения - ( byte ) ( a + b ) уже не получится

        // Неявное приведение:
        byte A = 1;
        A += 3; // эта сокращенная запись эквивалентна выаражению ниже
        A = ( byte ) (A + 3);
        byte B = -1;
        B >>>= 7; // (11_111_111 - в двоичном представлении) - делаем логичекий сдвиг вправо на 7 позиций
      /*  должно получиться 00_000_001. Однако при любой операциеи над byte происходит автоматическое расширение до
        int - 32 бита - 32 двоичных единицы  (а не 8). Логический сдвиг вправо (>>>) применяется к этому int-у а потом
        применяется обратное приведение в byte, то есть берутся младшие 8 бит - все единицы. Окончательное значение
        переменной byte B = -1, т.е. значение не изменилось!*/
        System.out.println(B);

// b = ( byte ) (b >>> 7)

    }


}

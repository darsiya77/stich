package Archive._2PrimitiveTypes.UpravlyauschieKonstrukcii.Tasks;

import java.util.Arrays;

public class Sliyanie_2_Massivov_For {
    public static void main(String[] args) {
        //_____________________________________________________________________________________________ 1 вариант:_____________
        int[] a1 = {1, 2};
        int[] a2 = {3, 4, 5}; // объявляю 2 массива
        //Arrays.sort(a1);Arrays.sort(a2); // сортирую каждый массив на возрастание
        System.out.println(Arrays.toString(mergeArrays(a1, a2))); // вывожу на печать массив, который возвращает метод
        System.out.println(Arrays.toString(SortirovkaSlitaya(a1, a2)));
//______________________________________________________________________________________________ 2 вариант:_____________
        int[] merge1 = mergeArrays(new int[]{1, 4, 6}, new int[]{5, 7}); // объявляю массив равный методу, в методе объявл 2 массива
        //System.out.println(Arrays.toString(merge1)); // вывожу на печать этот массив
    } // ________________________________________________________________________________________МОЙ МЕТОД:_____________

    public static int[] mergeArrays(int[] massiv1, int[] nassiv2) {
        int[] summ = new int[massiv1.length + nassiv2.length];
        int m = 0;
        int n = 0;
        int s = 0;
        int l1 = massiv1.length;
        int l2 = nassiv2.length;
        for (; m < l1 && n < l2; ) { // перебираем пока индексы (m и n 1 и 2 массивов не достигнут их длин
            if (massiv1[m] <= nassiv2[n]) {   // сравниваем индексы 1 и 2 массива, если индекс 1 массива <= инд 2 массива
                summ[s] = massiv1[m];
                m++;  // присваиваем массиву 3 меньший из элементов индекса и дальше гоним этот массив
            } else {
                summ[s] = nassiv2[n];
                n++; // иначе, присваиваем 1 эл. 3 массива значение 1 эл.второго массива
            }
            s++;
        } // после того как один массив из 2х закончился - смотрим условия и делаем дальше
        for (; m < l1; ) { // если 1 массив не закончился, то делаем дальше -
            summ[s] = massiv1[m];
            m++;
            s++; // след-й эл. 3го массива = след. эл. 1 массива.
        }
        for (; n < l2; ) {  // если 2 массив не закончился, то делаем дальше -
            summ[s] = nassiv2[n];
            n++;
            s++;
        }
        return summ;
    } //________________________________________________________________________________________________________________

    public static int[] SortirovkaSlitaya(int[] massiv1, int[] nassiv2) {
        int[] summ = new int[massiv1.length + nassiv2.length];
        int m = 0;
        int n = 0;
        int s = 0;
        int l1 = massiv1.length;
        int l2 = nassiv2.length;
        for (; m < l1 && n < l2; ) {
            if (massiv1[m] <= nassiv2[n]) {
                summ[s] = massiv1[m];
                m++;
            } else {
                summ[s] = nassiv2[n];
                n++;
            }
            s++;
        }
        for (; m < l1; ) {
            summ[s] = massiv1[m];
            m++;
            s++;
        }
        for (; n < l2; ) {
            summ[s] = nassiv2[n];
            n++;
            s++;
        }// Используем сортировку методом пузырька - https://www.youtube.com/watch?v=nqj_lSrTFko
        int cash; // вводим кэш, чиъто бы через него менять значение 1 и 2 элем.массива между собой
        boolean statusSort = false; // вводим буленовскую переменную для того что гонять цикл как надо
        while (!statusSort) {// по умолчанию фолз и при заменах - значит заходим в цикл
            statusSort = true;// сюда возвращаемся после каждого сравнения элементов и берем знач. тру

            /* если во всем массиве хотя бы 1 раз потребуедтся замена, то статус будет false пока цикл не завершится
             * и индекс не сравняется с длиной. Когда цикл завершится, попадаем в while и если статус false (а он будет
             * false, если была хотя бы 1 замена) то мы опять зайдем в цикл начиная с индекса 0. И так будем возвращаться в
             * вайл и идти по кругу пока не потребуется ни одной замены, после всех замен при новом цикле замены
             * не потребуются - а значит статус останется true и цикл завершится со статусом true и мы выйдем из while*/
            for (int c = 0; c < summ.length - 1; c++) {

                if (summ[c] > summ[c + 1]) {// если 1 эл. больше 2-го элемента этого массива - замена
                    statusSort = false;// если произвели замену - меняем бул на фолз, что бы цикл пошёл на повтор
                    cash = summ[c]; // помещаю значение 1 эл. в кэш
                    summ[c] = summ[c + 1]; // присваиваю значение 2-го эл. 1-му
                    summ[c + 1] = cash;
                }
            }
        }
        return summ;
    }
}  /*=================================================================================================================
Реализуйте метод, сливающий два отсортированных по неубыванию массива чисел в один отсортированный в том же
порядке массив. Массивы могут быть любой длины, в том числе нулевой.
Предполагается, что вы реализуете алгоритм слияния, имеющий линейную сложность: он будет идти по двум исходным
массивам и сразу формировать отсортированный результирующий массив. Так, чтобы сортировка полученного массива при
помощи Arrays.sort() уже не требовалась.К сожалению, автоматически это не проверить, так что это остается на вашей
совести :)
Воспользуйтесь предоставленным шаблоном. Декларацию класса, метод main и обработку ввода-вывода добавит проверяющая
система.

Пример ввода: {0, 2, 2} и {1, 3}
Пример вывода: {0, 1, 2, 2, 3}

Требования:
Cигнатура метода должна быть: mergeArrays(int[] a1, int[] a2)
==================================================================================================================*/
